<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="author" content="李金磊" >

    <title>Bezier 曲线绘制算法实现</title>

    

    <link rel="stylesheet" href="/stylesheets/styles.css">
    <link rel="stylesheet" href="/bower_components/normalize.css/normalize.css" >

    <script src="/javascripts/utils.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>
  <body>
    <div class="wrapper">

      <!-- 背景圆角 -->
      <div id="fixedRadiusCornerBg">
        <div id="fixedRadiusCornerBg_left" class="radiusCornerBg">
        </div>
        <div id="fixedRadiusCornerBg_right" class="radiusCornerBg">
        </div>
      </div>

      <header>
        <a href="/">
        <img id="round" style="" src="/images/avatar.png" />
        <p style="color:#252525;font-size:22px; font-style:bold;">李金磊的 Playground</p>
        <p style="color:#555555;text-align:left">「Less talk, more coding, professional made wheels.」</p>
      </a>
        <p class="view">


          <div id="tags">
            <h3>Tags：</h3>
            
    <a href="/tag/Canvas/index.html"> Canvas</a>

    <a href="/tag/Javascript/index.html"> Javascript</a>

    <a href="/tag/动效/index.html"> 动效</a>

    <a href="/tag/SVG/index.html"> SVG</a>

    <a href="/tag/Bezier/index.html"> Bezier</a>

    <a href="/tag/图形图像/index.html"> 图形图像</a>

    <a href="/tag/WebGL/index.html"> WebGL</a>

    <a href="/tag/流体模拟/index.html"> 流体模拟</a>

    <a href="/tag/运动学/index.html"> 运动学</a>

          </div>

      </header>

      <section id="content">
        <div>
  <h2>Bezier 曲线绘制算法实现</h2>
  <p class="time">19 Aug 2015</p>

  <p><b>Demo:</b>通过鼠标拖拽改变控制点</p>
  <canvas id="canvas">
    当前的浏览器不支持canvas, canvas是HTML5里才有的标签，主要用于图形绘制操作
  </canvas>

  <p></p>

  <script src="/javascripts/draw.js"></script>
  <script src="/javascripts/bezier.js"></script>

  <script type="text/javascript">
  var cvs = getCanvasByID("canvas");
  // var controlPoints = [{x:50, y:50}, {x:100, y:330}, {x:200, y:250}, {x:300, y:100}, {x:450, y:130}, {x:580, y:50}];
  var controlPoints = [{x:10, y:150}, {x:100, y:100}, {x:200, y:350}, {x:300, y:100}, {x:450, y:130}, {x:550, y:170}, {x:620, y:150}];
  //当前拖动的控制点索引
  var currentDragIndex;
  //监听鼠标事件
  cvs.element.addEventListener("mouseup", mouseUp, false);

  function fire(x, y) {
    var offset = 10;
    for (var i=0; i<controlPoints.length; i++) {
      var controlPoint = controlPoints[i];
      if (x<(controlPoint.x+offset) && x>(controlPoint.x-offset)
    && y<(controlPoint.y+offset) && y>(controlPoint.y-offset)) {
        currentDragIndex = i;
        cvs.element.addEventListener("mousemove", mouseMove, false);
        break;
      }
    }
  }

  function mouseUp() {
    cvs.element.removeEventListener("mousemove", mouseMove, false);
  }

  var mouseMove = function () {
    var e = event;
    var rect = canvas.getBoundingClientRect();
    var canX = e.pageX - rect.left;
    var canY = e.pageY - rect.top;
    controlPoints[currentDragIndex] = {x:canX, y:canY};
    updateDisplay();
  }

  function updateDisplay() {
    cvs.context.clearRect(0,0, canvasWidth, canvasHeight);
    drawCanvasBackground(cvs.context);
    cvs.context.strokeStyle = "#ffffff";
    cvs.context.lineWidth = 2;
    glDrawBezierCurve(controlPoints, cvs.context, true);
  }

  updateDisplay();
  </script>

  <p>以二次曲线为例绘制每一步的参考线网格</p>
  <canvas id="canvas1">
  </canvas>
  <script type="text/javascript">
  //接收参数为所有的顶点的集合及绘制上下文
  function drawBezierCurveSteps(points, context) {
    var firstP = points[0];
    var lastP = points[points.length - 1];
    //为保证采样足够，先计算控制多边形的总的边长，然后定义步长为 1/总边长
    var adgeArr = new Array();
    var adgeLength = calculateControlEdge(points, adgeArr);

    var step = 1.0/adgeLength;
    for (var i = 1; i < points.length; i++) {
      adgeArr[i - 1].calculateDelta(step);
    }
    //预先计算好基于步长的各边的x,y的增量
    for (var i=1; i<points.length; i++) {
      adgeArr[i-1].calculateDelta(step);
    }
    //绘制
    context.beginPath();
    context.strokeStyle = "#ffffff";
    for (var i=0; i<adgeLength; i+=20) {
      var p0X = points[0].x + adgeArr[0].delta.x*i;
      var p0Y = points[0].y + adgeArr[0].delta.y*i;
      var p1X = points[1].x + adgeArr[1].delta.x*i;
      var p1Y = points[1].y + adgeArr[1].delta.y*i;
      context.moveTo(p0X, p0Y);
      context.lineTo(p1X, p1Y);
    }
    context.stroke();

    //控制边
    context.save();
    context.beginPath();
    context.lineWidth = 2;
    context.moveTo(firstP.x, firstP.y);
    for (var i=1; i<points.length; i++) {
      context.lineTo(points[i].x, points[i].y);
    }
    context.stroke();
  }

  function calculateControlEdge(points, adgeArr) {
    var sideLength = 0;
    for (var i = 1; i < points.length; i++) {
      var lengthX = points[i].x - points[i - 1].x;
      var lengthY = points[i].y - points[i - 1].y;
      var adge = edge();
      adge.length = Math.sqrt(lengthX * lengthX + lengthY * lengthY);
      //  var angle = Math.atan2(lengthY, lengthX);
      adge.angleSin = lengthY / adge.length;
      adge.angleCos = lengthX / adge.length;
      sideLength += adge.length;
      adgeArr.push(adge);
    }
    return sideLength;
  }

  var cvs0 = getCanvasByID("canvas1");
  cvs0.context.clearRect(0,0, canvasWidth, canvasHeight);
  drawCanvasBackground(cvs0.context);
  drawBezierCurveSteps([{x:50, y:300}, {x:270, y:50}, {x:530, y:330}], cvs0.context);
  </script>

  <p>与 Canvas 提供的曲线函数绘制的图形对比:左边是调用 bezierCurveTo 绘制的，右边是调用自定义绘制函数 glDrawBezierCurve 绘制的 </p>
  <canvas id="canvas2">
  </canvas>
  <script type="text/javascript">
  var cvs2 = getCanvasByID("canvas2");
  var curvePoints = [{x:10, y:170}, {x:100, y:10}, {x:200, y:340}, {x:300, y:170}];
  drawCanvasBackground(cvs2.context);

  function drawCompare() {
    cvs2.context.strokeStyle = "#ffffff";
    cvs2.context.lineWidth = 2;

    drawBybezierCurveTo();
    //
    cvs2.context.translate(320, 0);
    glDrawBezierCurve(curvePoints, cvs2.context);
  }

  function drawBybezierCurveTo() {
    cvs2.context.beginPath();
    cvs2.context.moveTo(curvePoints[0].x, curvePoints[0].y);
    cvs2.context.bezierCurveTo(curvePoints[1].x, curvePoints[1].y, curvePoints[2].x, curvePoints[2].y, curvePoints[3].x, curvePoints[3].y);
    cvs2.context.stroke();
  }
  drawCompare()
  </script>

  <p>性能测试：<input id="runLoop" type="text" value="1000"></input>&nbsp;&nbsp;<input type="button" value=" 测试 " onclick="test();" /></p>
  <div id="toolBox">
    结果(耗时/豪秒)<br />
    bezierCurveTo: &nbsp;&nbsp;<input id="bezierCurveTo" type="text" value="0"></input><br />
    glDrawBezierCurve: &nbsp;&nbsp;<input id="glDrawBezierCurve" type="text" value="0">
  </div>
  <script type="text/javascript">
  function getMilliseconds(date) {
    return Date.UTC(date.getFullYear(), date.getMonth(), date.getDay(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds())
  }

  function test() {
    var runLoop = document.getElementById("runLoop").value;

    test_glDrawBezierCurve(runLoop);

    var currentDate = new Date();
    for (var i=0; i<runLoop; i++) {
      drawBybezierCurveTo();
    }
    var newDate = new Date();
    document.getElementById("bezierCurveTo").value = getMilliseconds(newDate) - getMilliseconds(currentDate);

  }

  function test_glDrawBezierCurve(runLoop) {
    var currentDate = new Date();
    for (var i=0; i<runLoop; i++) {
      glDrawBezierCurve(curvePoints, cvs2.context);
    }
    var newDate = new Date();
    document.getElementById("glDrawBezierCurve").value = getMilliseconds(newDate) - getMilliseconds(currentDate);
  }
  </script>

  <p><b>实现代码</b></p>
  <pre id="pre" class="prettyprint">
function glDrawBezierCurve(points, context, showEdge) {
  var firstP = points[0];
  var lastP = points[points.length - 1];
  //为保证采样足够，先计算控制多边形的总的边长，然后定义步长为 1/总边长
  var adgeArr = new Array();
  var totalStep = calculateControlEdge(points, adgeArr);
  //预先计算好基于步长的各边的x,y的增量
  var step = 1.0/totalStep;

  // 控制边
  if (showEdge) {
    context.beginPath();
    context.strokeStyle = "#666666";
    context.moveTo(firstP.x, firstP.y);
    for (var i=1; i< points.length; i++) {
      context.lineTo(points[i].x, points[i].y);
    }
    context.stroke();
  }

  //绘制
  context.beginPath();
  context.strokeStyle = "#ffffff";
  context.moveTo(firstP.x, firstP.y);
  var drawX, drawY;

  for (var i=0; i< totalStep; i+=5) {
    var ps = calculateReferenceLine(points, adgeArr, i, context, step);
    //计算绘制点的斜边长 及 与X轴的夹角
    var lengthX = ps[1].x - ps[0].x;
    var lengthY = ps[1].y - ps[0].y;

    var sideLength0 = Math.sqrt(lengthX*lengthX + lengthY*lengthY) ;
    var sideLength1 = sideLength0  * (step*i);
    drawX = ps[0].x + (lengthX/sideLength0) * sideLength1;
    drawY = ps[0].y + (lengthY/sideLength0) * sideLength1;
    context.lineTo(drawX, drawY);
  }
  context.stroke();

  //计算参考线,
  function calculateReferenceLine(ps, adges, index) {
    var arr = new Array();
    for (var j=0; j<(ps.length-1); j++) {
      var cx = ps[j].x + adges[j].delta.x*index;
      var cy = ps[j].y + adges[j].delta.y*index;
      arr.push({x:cx, y:cy});
    }
    if (arr.length == 2) {
      return arr;
    }
    else {
      var edgeList = new Array();
      var stepNew = step;
      var sideLength = calculateControlEdge(arr, edgeList, stepNew);
      return calculateReferenceLine(arr, edgeList,index, context);
    }
  }

  //计算控制多边形的边信息及总的边长
  function calculateControlEdge(points, adgeArr) {
    var sideLength = 0;
    for (var i = 1; i < points.length; i++) {
      var lengthX = points[i].x - points[i - 1].x;
      var lengthY = points[i].y - points[i - 1].y;
      var adge = edge();
      adge.length = Math.sqrt(lengthX * lengthX + lengthY * lengthY);
      adge.angleSin = lengthY / adge.length;
      adge.angleCos = lengthX / adge.length;
      sideLength += adge.length;
      adgeArr.push(adge);
    }
    if (!step) {
      step = 1.0 / sideLength;
    }
    for (var i = 1; i < points.length; i++) {
      adgeArr[i - 1].calculateDelta(step);
    }
    return sideLength;
  }
}

//定义边
function edge() {
 return {
   point0: {x:0, y:0},
   point1: {x:0, y:0},
   length: 0,
   angleCos: 0,
   angleSin: 0,
   delta: {x:0, y:0},//x,y的增量
   calculateDelta: function(step) {
     this.delta.x = step * this.length * this.angleCos;
     this.delta.y = step * this.length * this.angleSin;
   },
 }
}
  </pre>
</div>

      </section>

      <!-- 文字淡出 -->
      <!-- <div id="fadeoutContainer">
        <div id="topFadeoutCorner">
        </div>

      </div> -->
      <svg width="0" height="0">
        <defs>
          <clipPath id="clip3">
             <rect width="568" height="426" rx="85.2" ry="85.2"></rect>
          </clipPath>
          <clipPath id="clip4">
              <ellipse cx="284" cy="213" rx="284" ry="213"></ellipse>
          </clipPath>
          <filter id="filter2">
            <feGaussianBlur stdDeviation="10"></feGaussianBlur>
          </filter>
          <filter id="filter">
            <feGaussianBlur stdDeviation="0.03"></feGaussianBlur>
          </filter>
          <filter id="filter2">
            <feGaussianBlur stdDeviation="5"></feGaussianBlur>
          </filter>
          <linearGradient id="gradient" x1="0" y1="00%" x2="0" y2="100%">
            <stop stop-color="black" offset="0"></stop>
            <stop stop-color="white" offset="1"></stop>
          </linearGradient>
          <clipPath id="clipping4">
            <rect width="5680" height="2" rx="85.2" ry="85.2"></rect>
          </clipPath>
        </defs>
      </svg>
      <footer>
        <p><small>contact me：grenlight@icloud.com</small></p>
      </footer>
    </div>
    <script src="/javascripts/scale.fix.js"></script>
<script src="/javascripts/prettify/run_prettify.js"></script>
<link rel="stylesheet" href="/stylesheets/code-prettify-sunburst.css">

</script>
  </body>
</html>
