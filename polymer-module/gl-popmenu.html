<link rel="import"
      href="/bower_components/polymer/polymer.html">

<dom-module id="gl-popmenu">

<style>
:focus {
  border-width: 0px;
}
</style>

<template>
  {{items}} , [[items]]
  <svg id="svg" width="122" height="54" version="1.1" onblur="[[closeMenu()]]" style="cursor:hand;display:none;">
    <symbol id="border">
      <path  id="borderPath" d$="[[_calculateBorder()]]" />
    </symbol>
    <defs>
      <mask id="alphaMask" x="0" y="0" width="400" height="54">
        <rect x="0" y="0" width="400" height="54" style="stroke:none; fill: #333333" />
      </mask>
      <filter id="blurFilter" x="0" y="-5" width="400" height="54"
          <feGaussianBlur in="SourceGraphic" stdDeviation="3" y="-"/>
      </filter>
    </defs>
    <g id="group" style="line-height:32; font-size:16px;fill:#eeeeee;text-anchor: middle">
      <!-- 阴影 -->
      <use xlink:href="#border" x="0" y="3" style="fill:#000000;stroke-width:0; mask:url(#alphaMask); " />
      <use xlink:href="#border" x="0" y="0" style="fill:#555;stroke:#353535;stroke-width:1;" />
      <!-- 动态插入进来的文本节点在Safari上无法显示，故事先创建好文本节点 -->
      <text x="0" y="23" ></text>
      <text x="0" y="23" ></text>
      <text x="0" y="23" ></text>
      <text x="0" y="23" ></text>
      <text x="0" y="23" ></text>
      <text x="0" y="23" ></text>
    </g>
  </svg>
</template>

  <script>
   Polymer({
    is: "gl-popmenu",

    listeners: {
      tap: 'regularTap',
    },

    properties: {
      width: Number,
      tapRanges: Array,
      items: String,
      /*
      鼠标经过的按钮区域索引
      实际上是没有按钮结点的，通过鼠标坐标位置确定当前落在哪个虚拟按钮区域
      */
      movedIndex: Number,

      timer: Number ,
      animationNode:Object,
      currentScale:Number ,
      currentTranslate:Number,
      currentAlpha:Number,
      //是否为显示状态
      isShow: Boolean,
      //是否为动画执行过程中
      isAnimating: Boolean,
    },

    ready: function() {
      this.currentScale = this.currentAlpha = 0;
      this.currentTranslate = 30;
      this.isShow = this.isAnimating = false;
      this.animationNode = this.$.group;
    },

    attached: function() {
      var items = this.items.split(",");
      //按钮的点击范围
      this.tapRanges = new Array();
      var length = 0;
      var padding = 10;
      var rangeFrom = padding;
      for (var i=0; i<items.length; i++) {
        var pixelLength = items[i].length*16 + padding*2;
        var tempTo = rangeFrom+ pixelLength ;

        this.tapRanges[i] = {text:items[i], from:rangeFrom, to:tempTo, center:(rangeFrom+pixelLength/2)};
        length += items[i].length;
        rangeFrom = tempTo ;
      }
      var lastItem = this.tapRanges[(items.length-1)];
      lastItem.to = lastItem.to + padding;
      this.width = lastItem.to;
      this.addText();
      this.$.borderPath.setAttribute("d", this._calculateBorder());
      this.$.svg.setAttribute("width", this.width);

      Polymer.dom.flush();

      this.addEventListener("mousemove", this.handleMove, false);
      // this.$.svg.focus();

      this.showMenu();
    },

    addText: function() {
      var parent = this.$.group;
      var textNodes = Polymer.dom(parent).querySelectorAll('text');
      for (var i=0; i<this.tapRanges.length; i++) {
        var node = textNodes[i];
        Polymer.dom(node).setAttribute("x", this.tapRanges[i].center);
        node.textContent = this.tapRanges[i].text;
      }
    },

    changeTextColor: function(itemIndex) {
      var textNodes = Polymer.dom(this.$.group).querySelectorAll('text');
      for (var i=0; i<this.tapRanges.length; i++) {
        var node = textNodes[i];
        var fillColor ;
        if (i == itemIndex) {
          fillColor = "#ffffff";
        } else {
          fillColor = "#eeeeee";
        }
        node.style.fill = fillColor;
      }
    },

    regularTap: function(e) {
      var itemIndex = this.calculateTouchItemIndex(e);
      if (itemIndex < 0) {

      } else {

      }
      this.closeMenu();
    },

    handleMove: function() {
      var itemIndex = this.calculateTouchItemIndex("null",event);
      if (this.movedIndex != itemIndex) {
        this.changeTextColor(itemIndex);
        this.movedIndex = itemIndex;
      }
    },

    calculateTouchItemIndex: function(e, e2) {
      var touchX, touchY;
      var rect = this.$.svg.getBoundingClientRect();
      if (!e2) {
        touchX = e.detail.x - rect.left;
        touchY = e.detail.y - rect.top;
      } else {
        touchX = e2.pageX - rect.left;
        touchY = e2.pageY - rect.top;
      }

      var index = -1;
      if (touchY < 36) {
        for (var i=0; i<this.tapRanges.length; i++) {
          if (touchX < this.tapRanges[i].to) {
            index = i;
            break;
          }
        }
      }
      return index;
    },

    _calculateBorder: function() {
      var radius = 3;
      var trangleHeight = 8;
      var trangleWidth = 12;
      var minX = 0.5, maxX = !this.width ? 120 : (this.width-1), minY = 0.5, maxY = 36;
      var midX = maxX/2;
      return "M"+(minX+radius)+" "+minY +
      " L"+(maxX-radius)+" "+minY+
      " A"+radius+" "+radius+" 0 0 1 "+maxX+" "+(minY+radius)+
      " L"+maxX+" "+(maxY-radius)+
      " A"+radius+" "+radius+" 0 0 1 "+(maxX-radius)+" "+maxY+
      //尖角
      // " Q"+(midX)+" "+(maxY+trangleHeight/2)+" "+midX+" "+(maxY+trangleHeight);
      // " A"+radius+" "+radius+" 0 0 1 "+midX+" "+(maxY+trangleHeight);
      " L"+(midX+trangleWidth/2)+" "+maxY+
      " L"+(midX)+" "+(maxY+trangleHeight)+
      " L"+(midX-trangleWidth/2)+" "+(maxY)+

      " L"+(minX+radius)+" "+maxY+
      " A"+radius+" "+radius+" 0 0 1 "+minX+" "+(maxY-radius)+
      " L"+minX+" "+(minY+radius)+
      " A"+radius+" "+radius+" 0 0 1 "+(minX+radius)+" "+minY;
    },

    enterFrame: function() {
      this.isAnimating = true;
      if (this.isShow == false) {
        this.currentScale += 0.07;
        this.currentAlpha += 0.07;
        if (this.currentScale > 0.95) {
          this.outFrame();
        }
      } else {
        this.currentScale -= 0.05;
        this.currentAlpha -= 0.09;
        if (this.currentScale < 0.05) {
          this.outFrame();
        }
      }
      var tx = this.width/2 - this.currentScale*this.width/2;
      var ty = 54 - this.currentScale*54;
      this.animationNode.setAttribute("transform","matrix("+
      this.currentScale+", 0, 0," +
      this.currentScale + ","+ tx +"," + ty + ")");
      this.$.svg.style.opacity = this.currentAlpha;

      // console.log(this.currentAlpha);
      this.$.svg.style.display = "block"
      Polymer.dom.flush();
    },

    outFrame: function() {
      this.currentScale = this.currentAlpha = this.isShow ? 0 : 1;
      this.isShow = !this.isShow;
      this.isAnimating = false;
      clearInterval(this.timer)

      if (!this.isShow) {
        document.removeChild(this);
      }
    },

    showMenu: function() {
      if (!this.iaAnimating && !this.isShow) {
        this.timer = setInterval(this.enterFrame.bind(this), 15);
      }
    },

    closeMenu: function() {
      if (!this.iaAnimating && this.isShow) {
        this.timer = setInterval(this.enterFrame.bind(this), 15);
      }
    }

  });

  </script>
</dom-module>
