<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="author" content="李金磊" >

    <title>不使用WebGL模拟平面的3D透视效果</title>

    

    <link rel="stylesheet" href="/stylesheets/styles.css">
    <link rel="stylesheet" href="/bower_components/normalize.css/normalize.css" >

    <script src="/javascripts/utils.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>
  <body>
    <div class="wrapper">

      <!-- 背景圆角 -->
      <div id="fixedRadiusCornerBg">
        <div id="fixedRadiusCornerBg_left" class="radiusCornerBg">
        </div>
        <div id="fixedRadiusCornerBg_right" class="radiusCornerBg">
        </div>
      </div>

      <header>
        <a href="/">
        <img id="round" style="" src="/images/avatar.png" />
        <p style="color:#252525;font-size:22px; font-style:bold;">李金磊的 Playground</p>
        <p style="color:#555555;text-align:left">「Less talk, more coding, professional made wheels.」</p>
      </a>
        <p class="view">


          <div id="tags">
            <h3>Tags：</h3>
            
    <a href="/tag/Canvas/index.html"> Canvas</a>

    <a href="/tag/Javascript/index.html"> Javascript</a>

    <a href="/tag/动效/index.html"> 动效</a>

    <a href="/tag/SVG/index.html"> SVG</a>

    <a href="/tag/Bezier/index.html"> Bezier</a>

    <a href="/tag/图形图像/index.html"> 图形图像</a>

    <a href="/tag/WebGL/index.html"> WebGL</a>

    <a href="/tag/流体模拟/index.html"> 流体模拟</a>

    <a href="/tag/运动学/index.html"> 运动学</a>

          </div>

      </header>

      <section id="content">
        <div>
  <h2>不使用WebGL模拟平面的3D透视效果</h2>
  <p class="time">02 Jun 2014</p>


  <p><b>Demo:</b></p>
  <canvas id="canvas">
        当前的浏览器不支持canvas, canvas是HTML5里才有的标签，主要用于图形绘制操作
  </canvas>
  <div id="toolBox">
    <p><b>调整相机位置:</b>&nbsp;&nbsp;X:<span id="cameraX">350</span> Y:<span id="cameraY">50</span> Z:<span id="cameraZ">100</span></p>

  <p>x轴：<input id="cameraXRange" type="range"  min="20" max="550" value="300" step="20" onchange="changeCamera(0,this.value)" />
  y轴：<input type="range"  min="0" max="260" value="50" step="20" onchange="changeCamera(1,this.value)"/></p>
  </div>


  <b>思路</b>
  <p>定义一个相机位，找到相机与视口底边的垂直交点，由此三角形的两条直角边的比推算出做任意x轴上的视区范围</p>

<b>实现代码</b>
  <pre id="pre" class="prettyprint">
    ......
//沿z轴由近到远扫描地板像素
for (var z = 0; z< canvas.height; z++) {
  //X轴上的可视域
  var vx = edgeScale *  Math.sqrt(cm.y*cm.y + (cm.z+z)*(cm.z+z));
  //可视域缩放比
  var vxScale = standardPointX/vx;
  alpha = (z < canvas.height/1.5) ? (z/(canvas.height/1.5))*255 : 255;

  for (var x = 0; x < canvas.width; x++) {
    //画布上的像素点实际上对应于地板的x轴点
    /*
    在参考线右边的，颜色反转,
    取消了求绝对值，结果正如预期；
    */
    var arctualX = (standardPointX-x)*vxScale;
    var color = Math.ceil(arctualX/sideLength) % 2 === 0 ? 240 : 0;
    pixels[i] = pixels[i + 1] = pixels[i + 2] = color;
    pixels[i + 3] = alpha;
    i += 4;
  }
}
ctx.putImageData(imgdata, 0, 0);
  </pre>


  <script src="/javascripts/draw.js"></script>

  <script type="text/javascript">
  ctx.canvas.height  = 300;
  canvasHeight = canvas.offsetHeight;

  var Vector3 = function (x, y, z) {
      this.x = x || 0;
       this.y = y || 0;
       this.z = z || 0;
   };
   var Camera = function (x, y, z) {
       this.x = x || 0;
       this.y = y || 0;
       this.z = z || 0;
   }
   var cameraX = canvas.width, cameraY = 50, cameraZ = 100;
   function changeCamera(type, cx) {
     var elementID;
     switch (type) {
       case 0:
        cameraX = cx;
        elementID = "cameraX";
         break;
       case 1:
        cameraY = cx;
        elementID = "cameraY";
        break;
      default:
        cameraZ = cx;
        elementID = "cameraZ";
        break;
     }
     document.getElementById(elementID).innerHTML=cx;
     updateDisplay();
   }

  function updateDisplay() {
    ctx.clearRect(0,0, canvasWidth, canvasHeight);
     drawCanvasBackground();

     var imgdata = ctx.getImageData(0, 0, canvas.width, canvas.height);
     var pixels = imgdata.data;
     var cm = new Camera(cameraX, cameraY, cameraZ);
     console.log(cameraZ);
     //地板格子边长
     var sideLength = 50;

     var standardPointX = cm.x;
     //两个直角边的比,用于计算X轴上的可视域
     var edgeScale = standardPointX / Math.sqrt(cm.y*cm.y + cm.z*cm.z);

     var i = 0;
     var alpha = 255;
     //沿z轴由近到远扫描地板像素
     for (var z = 0; z<canvas.height; z++) {
       //X轴上的可视域
       var vx = edgeScale *  Math.sqrt(cm.y*cm.y + (cm.z+z)*(cm.z+z));
       //可视域缩放比
       var vxScale = standardPointX/vx;
       alpha = (z < canvas.height/1.5) ? (z/(canvas.height/1.5))*255 : 255;

       //z轴上的格子
       var zColor = Math.ceil((canvas.height-z)*vxScale/sideLength);
       for (var x = 0; x < canvas.width; x++) {
         //画布上的像素点实际上对应于地板的x轴点
         /*
         在参考线右边的，颜色反转,
         取消了求绝对值，结果正如预期；
         */
         var arctualX = (standardPointX-x)*vxScale;
         var color = (Math.ceil(arctualX/sideLength)+zColor) % 2 === 0 ? 240 : 0;
         pixels[i] = pixels[i + 1] = pixels[i + 2] = color;
         pixels[i + 3] = alpha;
         i += 4;
       }
     }
     ctx.putImageData(imgdata, 0, 0);
  }

  setCanvasScaleIfNeeds();

  var cameraXRange = document.getElementById("cameraXRange");
  cameraXRange.setAttribute("max", cameraX);
  cameraXRange.setAttribute("value", cameraX);
  changeCamera(0, cameraX);

  </script>

</div>

      </section>

      <!-- 文字淡出 -->
      <!-- <div id="fadeoutContainer">
        <div id="topFadeoutCorner">
        </div>

      </div> -->
      <svg width="0" height="0">
        <defs>
          <clipPath id="clip3">
             <rect width="568" height="426" rx="85.2" ry="85.2"></rect>
          </clipPath>
          <clipPath id="clip4">
              <ellipse cx="284" cy="213" rx="284" ry="213"></ellipse>
          </clipPath>
          <filter id="filter2">
            <feGaussianBlur stdDeviation="10"></feGaussianBlur>
          </filter>
          <filter id="filter">
            <feGaussianBlur stdDeviation="0.03"></feGaussianBlur>
          </filter>
          <filter id="filter2">
            <feGaussianBlur stdDeviation="5"></feGaussianBlur>
          </filter>
          <linearGradient id="gradient" x1="0" y1="00%" x2="0" y2="100%">
            <stop stop-color="black" offset="0"></stop>
            <stop stop-color="white" offset="1"></stop>
          </linearGradient>
          <clipPath id="clipping4">
            <rect width="5680" height="2" rx="85.2" ry="85.2"></rect>
          </clipPath>
        </defs>
      </svg>
      <footer>
        <p><small>contact me：grenlight@icloud.com</small></p>
      </footer>
    </div>
    <script src="/javascripts/scale.fix.js"></script>
<script src="/javascripts/prettify/run_prettify.js"></script>
<link rel="stylesheet" href="/stylesheets/code-prettify-sunburst.css">

</script>
  </body>
</html>
