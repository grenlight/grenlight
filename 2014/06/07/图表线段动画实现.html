<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="author" content="李金磊" >

    <title>图表线段动画实现</title>

    

    <link rel="stylesheet" href="/stylesheets/styles.css">
    <link rel="stylesheet" href="/bower_components/normalize.css/normalize.css" >

    <script src="/javascripts/utils.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>
  <body>
    <div class="wrapper">

      <!-- 背景圆角 -->
      <div id="fixedRadiusCornerBg">
        <div id="fixedRadiusCornerBg_left" class="radiusCornerBg">
        </div>
        <div id="fixedRadiusCornerBg_right" class="radiusCornerBg">
        </div>
      </div>

      <header>
        <a href="/">
        <img id="round" style="" src="/images/avatar.png" />
        <p style="color:#252525;font-size:22px; font-style:bold;">李金磊的 Playground</p>
        <p style="color:#555555;text-align:left">「Less talk, more coding, professional made wheels.」</p>
      </a>
        <p class="view">


          <div id="tags">
            <h3>Tags：</h3>
            
    <a href="/tag/Canvas/index.html"> Canvas</a>

    <a href="/tag/Javascript/index.html"> Javascript</a>

    <a href="/tag/动效/index.html"> 动效</a>

    <a href="/tag/SVG/index.html"> SVG</a>

    <a href="/tag/Bezier/index.html"> Bezier</a>

    <a href="/tag/图形图像/index.html"> 图形图像</a>

    <a href="/tag/WebGL/index.html"> WebGL</a>

    <a href="/tag/流体模拟/index.html"> 流体模拟</a>

    <a href="/tag/运动学/index.html"> 运动学</a>

          </div>

      </header>

      <section id="content">
        <div>
  <h2>图表线段动画实现</h2>
  <p class="time">07 Jun 2014</p>


  <p><b>Demo:</b></p>
  <canvas id="canvas">
        当前的浏览器不支持canvas, canvas是HTML5里才有的标签，主要用于图形绘制操作
  </canvas>

  <p>实现代码</p>
  <p>1,定义线段对象</p>
  <pre id="pre" class="prettyprint">
function createALine(ctx) {
  return {
    leftPin: {x:0, y:0},//左节点
    rightPin: {x:0, y:0},//右节点，同时也是下一个线段需要的左节点
    step: {left:0, right:0}, //每一帧节点移动的距离
    init: function(lp, rp) {
     this.leftPin = {x:lp.x, y:centerY};
     this.rightPin = {x:rp.x, y:centerY};
     this.step = {left:(lp.y-centerY)/maxFrame, right:(rp.y-centerY)/maxFrame};
     this.draw(this.leftPin.y, this.rightPin.y);
    },
    update: function(leftY, frame, isFirstLine) {
      //左边的Y坐标是由上一条线段的右结点确定的
      var leftPinY = isFirstLine ? (centerY + this.step.left*frame) : leftY;
      this.draw(leftPinY, centerY + this.step.right*frame);
    },
    draw: function(leftY, rightY) {
      this.leftPin.y = leftY;
      this.rightPin.y = rightY;
      var path = new Path2D();
      path.moveTo(this.leftPin.x, this.leftPin.y);
      path.lineTo(this.rightPin.x, this.rightPin.y);
      ctx.stroke(path);
    }
  }
}
  </pre>

  <p>2,enterFrame() 方法里让绘制在直线或最终曲线状态时暂停60帧</p>
  <pre class="prettyprint">
function enterFrame() {
  //直线或最终曲线状态时暂停60帧
  if ((currentFrame == 0 || currentFrame == maxFrame) && stopFrame < 60) {
    stopFrame ++;
    return;
  }
  if (ifNeedsDrawBack) {
    currentFrame--;
    if (currentFrame == 0) {
      ifNeedsDrawBack = false;
    }
  } else {
    currentFrame++;
    if (currentFrame == maxFrame ) {
      ifNeedsDrawBack = true;
    }
  }
  stopFrame = 0;
  updateDisplay()
}
  </pre>

  <p>3,遍历所有线段，调用其update()方法绘制。</p>
  <pre class="prettyprint">
......
for (var i=0; i< lines.length; i++) {
  var line = lines[i];
  var rightP = points[i+1];
  var leftP = points[i];
  var isFirstLine = true;
  if (i > 0) {
    leftP = lines[i-1].rightPin;
    isFirstLine = false;
  }
  line.update(leftP.y, currentFrame, isFirstLine);
}
  </pre>

  <script src="/javascripts/draw.js"></script>

  <script type="text/javascript">
  ctx.canvas.height  = 280;
  canvasHeight = canvas.offsetHeight;
  centerY = canvasHeight/2.0;

  function createALine(ctx) {
    return {
      leftPin: {x:0, y:0},//左节点
      rightPin: {x:0, y:0},//右节点，同时也是下一个线段需要的左节点
      step: {left:0, right:0}, //每一帧节点移动的距离
      init: function(lp, rp) {
       this.leftPin = {x:lp.x, y:centerY};
       this.rightPin = {x:rp.x, y:centerY};
       this.step = {left:(lp.y-centerY)/maxFrame, right:(rp.y-centerY)/maxFrame};
       this.draw(this.leftPin.y, this.rightPin.y);
      },
      update: function(leftY, frame, isFirstLine) {
        //左边的Y坐标是由上一条线段的右结点确定的
        var leftPinY = isFirstLine ? (centerY + this.step.left*frame) : leftY;
        this.draw(leftPinY, centerY + this.step.right*frame);
      },
      draw: function(leftY, rightY) {
        this.leftPin.y = leftY;
        this.rightPin.y = rightY;
        ctx.beginPath();
        ctx.moveTo(this.leftPin.x, this.leftPin.y);
        ctx.lineTo(this.rightPin.x, this.rightPin.y);
        ctx.stroke();
      }
    }
  }

  var points = [{x:0, y:canvasHeight}, {x:90, y:centerY},
    {x:130, y:canvasHeight}, {x:160, y:centerY-10},
     {x:200, y:centerY+70},{x:250, y:centerY},
     {x:320, y:canvasHeight}, {x:390, y:centerY-20},
     {x:480, y:centerY+50}, {x:canvasWidth, y:centerY-70}];

  //线段数组
  var lines = new Array();

  //初始化所有线段
  function initLines() {
    for (var i=0; i< (points.length-1); i++) {
      var line = createALine(ctx);
      line.init(points[i], points[i+1]);
      lines[i] = line;
    }
  }

  //反向绘制
  var ifNeedsDrawBack = false;
  var currentFrame = 0;
  var maxFrame = 60;
  var stopFrame = 0;

  function enterFrame() {
    //直线或最终曲线状态时暂停60帧
    if ((currentFrame == 0 || currentFrame == maxFrame) && stopFrame < 60) {
      stopFrame ++;
      return;
    }
    if (ifNeedsDrawBack) {
      currentFrame--;
      if (currentFrame == 0) {
        ifNeedsDrawBack = false;
      }
    } else {
      currentFrame++;
      if (currentFrame == maxFrame ) {
        ifNeedsDrawBack = true;
      }
    }
    stopFrame = 0;
    updateDisplay()
  }

  function updateDisplay() {
    ctx.clearRect(0,0, canvasWidth, canvasHeight);
    drawCanvasBackground();

    ctx.strokeStyle = "#ffffff";
    for (var i=0; i< lines.length; i++) {
      var line = lines[i];
      var rightP = points[i+1];
      var leftP = points[i];
      var isFirstLine = true;
      if (i > 0) {
        leftP = lines[i-1].rightPin;
        isFirstLine = false;
      }
      line.update(leftP.y, currentFrame, isFirstLine);
    }
  }

  setCanvasScaleIfNeeds();
  initLines();
  setInterval("enterFrame()", 5);

  </script>

</div>

      </section>

      <!-- 文字淡出 -->
      <!-- <div id="fadeoutContainer">
        <div id="topFadeoutCorner">
        </div>

      </div> -->
      <svg width="0" height="0">
        <defs>
          <clipPath id="clip3">
             <rect width="568" height="426" rx="85.2" ry="85.2"></rect>
          </clipPath>
          <clipPath id="clip4">
              <ellipse cx="284" cy="213" rx="284" ry="213"></ellipse>
          </clipPath>
          <filter id="filter2">
            <feGaussianBlur stdDeviation="10"></feGaussianBlur>
          </filter>
          <filter id="filter">
            <feGaussianBlur stdDeviation="0.03"></feGaussianBlur>
          </filter>
          <filter id="filter2">
            <feGaussianBlur stdDeviation="5"></feGaussianBlur>
          </filter>
          <linearGradient id="gradient" x1="0" y1="00%" x2="0" y2="100%">
            <stop stop-color="black" offset="0"></stop>
            <stop stop-color="white" offset="1"></stop>
          </linearGradient>
          <clipPath id="clipping4">
            <rect width="5680" height="2" rx="85.2" ry="85.2"></rect>
          </clipPath>
        </defs>
      </svg>
      <footer>
        <p><small>contact me：grenlight@icloud.com</small></p>
      </footer>
    </div>
    <script src="/javascripts/scale.fix.js"></script>
<script src="/javascripts/prettify/run_prettify.js"></script>
<link rel="stylesheet" href="/stylesheets/code-prettify-sunburst.css">

</script>
  </body>
</html>
