!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("GREN")):"function"==typeof define&&define.amd?define("TRANSITION",["GREN"],t):"object"==typeof exports?exports.TRANSITION=t(require("GREN")):e.TRANSITION=t(e.GREN)}(this,function(e){return function(e){function t(i){if(r[i])return r[i].exports;var n=r[i]={exports:{},id:i,loaded:!1};return e[i].call(n.exports,n,n.exports,t),n.loaded=!0,n.exports}var r={};return t.m=e,t.c=r,t.p="",t(0)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=r(1);Object.keys(i).forEach(function(e){"default"!==e&&Object.defineProperty(t,e,{enumerable:!0,get:function(){return i[e]}})})},function(e,t,r){"use strict";function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function o(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var r=0;r<t.length;r++){var i=t[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}return function(t,r,i){return r&&e(t.prototype,r),i&&e(t,i),t}}(),s=function f(e,t,r){null===e&&(e=Function.prototype);var i=Object.getOwnPropertyDescriptor(e,t);if(void 0===i){var n=Object.getPrototypeOf(e);return null===n?void 0:f(n,t,r)}if("value"in i)return i.value;var o=i.get;if(void 0!==o)return o.call(r)},l=r(2),u=(t.Roll=function(e){function t(){var e=arguments.length<=0||void 0===arguments[0]?300:arguments[0],r=arguments.length<=1||void 0===arguments[1]?100:arguments[1],o=arguments.length<=2||void 0===arguments[2]?"../bin/texture.png":arguments[2];i(this,t);var a=n(this,Object.getPrototypeOf(t).call(this));if(a.renderer=new l.WebGLRenderer,a.renderer.setStyle(e,r,"margin:0px; position:absolute; z-index:1;"),a.gl=a.renderer.gl,a.domElement=a.renderer.canvas,a.renderer.isWebGLSuported===!1)return n(a);e=a.renderer.canvasWidth,r=a.renderer.canvasHeight,a.pMatrix=l.Matrix4.perspective(65/180*Math.PI,e/r,.1,5e4),a.mvMatrix=new l.Matrix4,l.Matrix4.translate(a.mvMatrix,[-0,0,-2]),l.Matrix4.scale(a.mvMatrix,[1/e,1/e,0]),l.Matrix4.rotate(a.mvMatrix,a.mvMatrix,-56/180*Math.PI,[1,0,0]),l.Matrix4.rotate(a.mvMatrix,a.mvMatrix,35/180*Math.PI,[0,0,1]),a.mvMatrix1=new l.Matrix4,l.Matrix4.translate(a.mvMatrix1,[-.3,0,-1.19999]),l.Matrix4.scale(a.mvMatrix1,[1/e,1/e,0]),l.Matrix4.rotate(a.mvMatrix1,a.mvMatrix1,-66/180*Math.PI,[1,0,0]),l.Matrix4.rotate(a.mvMatrix1,a.mvMatrix1,75/180*Math.PI,[0,0,1]),a._initProgram(),a.mesh=new l.PlaneGeometry(e,r,1,Math.floor(r/5));var s=a.gl.createArrayBufferWithTypedArray(a.mesh.vertices);a.gl.bindBuffer(a.gl.ARRAY_BUFFER,s),a.gl.vertexAttribPointer(a.prg.vertexPosition,3,a.gl.FLOAT,!1,0,0),a.gl.enableVertexAttribArray(a.prg.vertexPosition);var u=a.gl.createArrayBufferWithTypedArray(a.mesh.textureCoords);a.gl.bindBuffer(a.gl.ARRAY_BUFFER,u),a.gl.vertexAttribPointer(a.prg.vTextureCoord,2,a.gl.FLOAT,!1,0,0),a.gl.enableVertexAttribArray(a.prg.vTextureCoord);var f=a.gl.createElementBufferWithTypedArray(a.mesh.indices);return a.gl.bindBuffer(a.gl.ELEMENT_ARRAY_BUFFER,f),a.rollTo=0,a.speed=Math.ceil(a.renderer.canvasHeight/180),a.isRollUp=!0,a.glTexture=new l.GLTexture2D(a.gl,o,function(){a.gl.activeTexture(a.gl.TEXTURE0),a.gl.bindTexture(a.gl.TEXTURE_2D,a.glTexture.texture),a.gl.uniform1i(a.prg.texture,0),a.startAnimating()}),a}return o(t,e),a(t,[{key:"_initProgram",value:function(){this.prg=this.gl.makeProgram(u,l.basicTextureFS),this.prg.setAttribLocations(["vertexPosition","vTextureCoord"]),this.prg.setUniformLocations(["pMatrix","mvMatrix","startRadius","rollTo","halfHeight","texture","useTexture","color"]),this.gl.uniformMatrix4fv(this.prg.pMatrix,!1,this.pMatrix),this.gl.uniform1f(this.prg.startRadius,30*window.devicePixelRatio),this.gl.uniform1f(this.prg.halfHeight,this.renderer.centerY),this.gl.uniform4fv(this.prg.color,[1,1,1,.95])}},{key:"updateData",value:function(){this.isRollUp?(this.rollTo+=this.speed,this.rollTo>=this.renderer.canvasHeight&&(this.rollTo=this.renderer.canvasHeight,this.isRollUp=!1)):(this.rollTo-=this.speed,this.rollTo<=0&&(this.rollTo=0,this.isRollUp=!0)),this.gl.uniform1f(this.prg.rollTo,this.rollTo)}},{key:"enterFrame",value:function(){this.updateData(),s(Object.getPrototypeOf(t.prototype),"enterFrame",this).call(this),this.gl.clearColor(0,0,0,0),this.gl.viewport(0,0,this.renderer.canvasWidth,this.renderer.canvasHeight),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT),this.gl.enable(this.gl.DEPTH_TEST),this.gl.depthFunc(this.gl.LEQUAL),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA),this.gl.uniformMatrix4fv(this.prg.mvMatrix,!1,this.mvMatrix),this.gl.uniform1i(this.prg.useTexture,!0),this.gl.drawElements(this.gl.TRIANGLES,this.mesh.indices.length,this.gl.UNSIGNED_SHORT,0)}}]),t}(l.IAnimation),"\nattribute vec3 vertexPosition;\nattribute vec2 vTextureCoord;\n\nuniform mat4 mvMatrix;\nuniform mat4 pMatrix;\nuniform bool useTexture;\n\nuniform float startRadius; // 开始卷动的半径\nuniform float rollTo; // 卷动到哪个位置\nuniform float halfHeight; // 屏幕一半的高度,用来计算顶点离坐标离屏幕原点(左下角)的位置\n\nvarying vec2 texCoord;\n\nconst float PI = 3.1415926;\nvoid main(void) {\n    if (useTexture) {\n        texCoord = vTextureCoord;\n    }\n    // 离左下角的距离\n    float distance = halfHeight + vertexPosition.y;\n    if (distance < rollTo) {\n        float maxRadius = 1.5 * startRadius;\n        float stepRadius = (maxRadius - startRadius) / (halfHeight * 2.0) ;\n        // 每一点的卷动半径是不一样的\n        float newRadius = startRadius + stepRadius * distance;\n        // 卷动停止点的半径\n        float targetRadius = startRadius + stepRadius * rollTo;\n        \n         // 卷动的圆的周长\n        float perimeter = newRadius * 2.0 * PI;\n        //卷起的弧度,每一个顶点被卷起的弧度值是不一样的;\n        // float degress = ((rollTo-distance) / perimeter) * (2.0 * PI);\n        float degress = (mod((rollTo-distance), perimeter)  / perimeter) * (2.0 * PI);\n\n        vec3 newPosition = vertexPosition.xyz;\n        newPosition.y = (rollTo - sin(degress) * newRadius) - halfHeight;\n        newPosition.z  += (targetRadius - newRadius)/2.0 + (newRadius - cos(degress)*newRadius) + 1.0;\n        gl_Position = pMatrix * mvMatrix * vec4(newPosition, 1.0);\n    } else {\n        gl_Position = pMatrix * mvMatrix * vec4(vertexPosition, 1.0);\n    }\n   \n}\n")},function(t,r){t.exports=e}])});